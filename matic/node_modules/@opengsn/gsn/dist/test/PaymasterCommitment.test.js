"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const test_helpers_1 = require("@openzeppelin/test-helpers");
const bn_js_1 = __importDefault(require("bn.js"));
const Utils_1 = require("../src/common/Utils");
const TypedRequestData_1 = __importStar(require("../src/common/EIP712/TypedRequestData"));
const TestUtils_1 = require("./TestUtils");
const StakeManager = artifacts.require('StakeManager');
const Forwarder = artifacts.require('Forwarder');
const Penalizer = artifacts.require('Penalizer');
const TestUtil = artifacts.require('TestUtil');
const TestRecipient = artifacts.require('TestRecipient');
const TestPaymasterConfigurableMisbehavior = artifacts.require('TestPaymasterConfigurableMisbehavior');
// given partial request, fill it in from defaults, and return request and signature to send.
// if nonce is not explicitly specified, read it from forwarder
async function makeRequest(web3, req, defaultRequest, chainId, forwarderInstance) {
    var _a;
    const filledRequest = {
        request: Object.assign(Object.assign({}, defaultRequest.request), req.request),
        relayData: Object.assign(Object.assign({}, defaultRequest.relayData), req.relayData)
    };
    // unless explicitly set, read nonce from network.
    if (((_a = filledRequest.request.nonce) !== null && _a !== void 0 ? _a : '0') === '0') {
        filledRequest.request.nonce = (await forwarderInstance.getNonce(filledRequest.request.from)).toString();
    }
    const sig = await Utils_1.getEip712Signature(web3, new TypedRequestData_1.default(chainId, filledRequest.relayData.forwarder, filledRequest));
    return {
        req: filledRequest,
        sig
    };
}
// verify the paymaster's commitment:
// - PM always pay for non-reverted TXs (either high or low gas use)
// - if preRelayedCall reverts: PM always pay (=as long as commitment>preRelayedCallGasLimit)
// - standard forwarder reverts: PM always pay (since commitment > gas of (preRelayedCall,forwarder))
// - nonstandard forwardeR: PM pays above commitment
// - trusted recipient: PM pays above commitment.
contract('Paymaster Commitment', function ([_, relayOwner, relayManager, relayWorker, senderAddress, other]) {
    const RelayCallStatusCodes = {
        OK: new bn_js_1.default('0'),
        RelayedCallFailed: new bn_js_1.default('1'),
        RejectedByPreRelayed: new bn_js_1.default('2'),
        RejectedByForwarder: new bn_js_1.default('3'),
        RejectedByRecipientRevert: new bn_js_1.default('4'),
        PostRelayedFailed: new bn_js_1.default('5'),
        PaymasterBalanceChanged: new bn_js_1.default('6')
    };
    let chainId;
    let relayHub;
    let stakeManager;
    let penalizer;
    let relayHubInstance;
    let recipientContract;
    let paymasterContract;
    let forwarderInstance;
    let target;
    let paymaster;
    let forwarder;
    const baseRelayFee = '0';
    const pctRelayFee = '0';
    before(async function () {
        stakeManager = await StakeManager.new();
        penalizer = await Penalizer.new();
        relayHubInstance = await TestUtils_1.deployHub(stakeManager.address, penalizer.address);
        forwarderInstance = await Forwarder.new();
        forwarder = forwarderInstance.address;
        recipientContract = await TestRecipient.new(forwarder);
        const testUtil = await TestUtil.new();
        chainId = (await testUtil.libGetChainID()).toNumber();
        // register hub's RelayRequest with forwarder, if not already done.
        await forwarderInstance.registerRequestType(TypedRequestData_1.GsnRequestType.typeName, TypedRequestData_1.GsnRequestType.typeSuffix);
        target = recipientContract.address;
        relayHub = relayHubInstance.address;
        await stakeManager.stakeForAddress(relayManager, 1000, {
            value: test_helpers_1.ether('2'),
            from: relayOwner
        });
        await stakeManager.authorizeHubByOwner(relayManager, relayHub, { from: relayOwner });
        await relayHubInstance.addRelayWorkers([relayWorker], { from: relayManager });
        await relayHubInstance.registerRelayServer(baseRelayFee, pctRelayFee, 'url', { from: relayManager });
    });
    describe('paymaster commitments', function () {
        const gasPrice = '1';
        const gasLimit = '1000000';
        const senderNonce = '0';
        let sharedRelayRequestData;
        const paymasterData = '0x';
        const clientId = '1';
        const externalGasLimit = 5e6;
        beforeEach(async () => {
            // brand new paymaster for each test...
            paymasterContract = await TestPaymasterConfigurableMisbehavior.new();
            paymaster = paymasterContract.address;
            await paymasterContract.setTrustedForwarder(forwarder);
            await paymasterContract.setRelayHub(relayHub);
            await relayHubInstance.depositFor(paymaster, {
                value: test_helpers_1.ether('1'),
                from: other
            });
            sharedRelayRequestData = {
                request: {
                    to: target,
                    data: '',
                    from: senderAddress,
                    nonce: senderNonce,
                    value: '0',
                    gas: gasLimit
                },
                relayData: {
                    pctRelayFee,
                    baseRelayFee,
                    gasPrice,
                    relayWorker,
                    forwarder,
                    paymaster,
                    paymasterData,
                    clientId
                }
            };
        });
        let paymasterBalance;
        beforeEach(async () => {
            paymasterBalance = (await relayHubInstance.balanceOf(paymaster));
        });
        it('paymaster should pay for normal request', async () => {
            const r = await makeRequest(web3, {
                request: {
                    // nonce: '4',
                    data: recipientContract.contract.methods.emitMessage('').encodeABI()
                },
                relayData: { paymaster }
            }, sharedRelayRequestData, chainId, forwarderInstance);
            const res = await relayHubInstance.relayCall(10e6, r.req, r.sig, '0x', externalGasLimit, {
                from: relayWorker,
                gas: externalGasLimit,
                gasPrice
            });
            // gasPrice is '1', so price=gasUsed...
            test_helpers_1.expectEvent(res, 'TransactionRelayed', { status: '0' });
            const gasUsed = res.receipt.gasUsed;
            const paid = paymasterBalance.sub(await relayHubInstance.balanceOf(paymaster)).toNumber();
            // console.log('actual paid=', paid, 'gasUsed=', gasUsed, 'diff=', paid - gasUsed)
            assert.closeTo(paid, gasUsed, 50);
        });
        it('paymaster should not change its acceptanceBudget before transaction', async () => {
            // the protocol of the relay to perform a view function of relayCall(), and then
            // issue it on-chain.
            // this test comes to verify the paymaster didn't chagne its acceptanceBalance between these
            // calls to a higher value.
            // it is assumed that the relay already made the view function and validated the acceptanceBalance to
            // be small, and now making a 2nd call on-chain, but with the acceptanceBalance as parameter.
            // the RELAYER (not paymaster) will pay for this reject - but at least it is very small, as it is
            // "fails-fast", as one of the first validation tests in relayCall
            const r = await makeRequest(web3, {
                request: {
                    // nonce: '4',
                    data: recipientContract.contract.methods.emitMessage('').encodeABI()
                },
                relayData: { paymaster }
            }, sharedRelayRequestData, chainId, forwarderInstance);
            const gasLimits = await paymasterContract.getGasLimits();
            // fail if a bit lower
            test_helpers_1.expectRevert(relayHubInstance.relayCall(parseInt(gasLimits.acceptanceBudget) - 1, r.req, r.sig, '0x', externalGasLimit, {
                from: relayWorker,
                gas: externalGasLimit,
                gasPrice
            }), 'unexpected high acceptanceBudget');
            // but succeed if the value is OK
            const res = await relayHubInstance.relayCall(parseInt(gasLimits.acceptanceBudget), r.req, r.sig, '0x', externalGasLimit, {
                from: relayWorker,
                gas: externalGasLimit,
                gasPrice
            });
            test_helpers_1.expectEvent(res, 'TransactionRelayed', { status: '0' });
        });
        it('2nd payment should be 15k cheaper for relay than paymaster', async () => {
            // we can't do much about it: gasleft doesn't take into account "refunds", so
            //  we charge paymaster for reported gas, even though the evm will refund (the relay)
            //  at the end for some of it.
            //  if the paymaster's pre/post calls cause more refund, it will ALSO benefit the relayer, not the paymaster.
            //  NOTE: this means that
            //  GAS TOKENS CAN'T BE USED BY PAYMASTER - unless it is the same owner of relay and paymaster,
            const r = await makeRequest(web3, {
                request: {
                    data: recipientContract.contract.methods.emitMessage('').encodeABI()
                }
            }, sharedRelayRequestData, chainId, forwarderInstance);
            const res = await relayHubInstance.relayCall(10e6, r.req, r.sig, '0x', externalGasLimit, {
                from: relayWorker,
                gas: externalGasLimit,
                gasPrice
            });
            // gasPrice is '1', so price=gasUsed...
            const gasUsed = res.receipt.gasUsed;
            test_helpers_1.expectEvent(res, 'TransactionRelayed', { status: '0' });
            const paymasterPaid = paymasterBalance.sub(await relayHubInstance.balanceOf(paymaster)).toNumber();
            assert.closeTo(paymasterPaid, parseInt(gasUsed) + 15000, 50);
        });
        it('paymaster should not pay for OOG in preRelayedCall (under commitment gas)', async () => {
            await paymasterContract.setOverspendAcceptGas(true);
            // NOTE: as long as commitment>preRelayedCallGasLimit
            const r = await makeRequest(web3, {
                request: {
                    // nonce: '4',
                    data: recipientContract.contract.methods.emitMessage('').encodeABI()
                },
                relayData: { paymaster }
            }, sharedRelayRequestData, chainId, forwarderInstance);
            const res = await relayHubInstance.relayCall(10e6, r.req, r.sig, '0x', externalGasLimit, {
                from: relayWorker,
                gas: externalGasLimit,
                gasPrice
            });
            test_helpers_1.expectEvent(res, 'TransactionRejectedByPaymaster', { reason: null });
            const paid = paymasterBalance.sub(await relayHubInstance.balanceOf(paymaster)).toNumber();
            assert.equal(paid, 0);
        });
        it('paymaster should not pay for Forwarder revert (under commitment gas)', async () => {
            // NOTE: as long as commitment > preRelayedCallGasLimit
            const r = await makeRequest(web3, {
                request: {
                    nonce: '4',
                    data: recipientContract.contract.methods.emitMessage('').encodeABI()
                },
                relayData: { paymaster }
            }, sharedRelayRequestData, chainId, forwarderInstance);
            const res = await relayHubInstance.relayCall(10e6, r.req, r.sig, '0x', externalGasLimit, {
                from: relayWorker,
                gas: externalGasLimit,
                gasPrice
            });
            test_helpers_1.expectEvent(res, 'TransactionRejectedByPaymaster', { reason: TestUtils_1.encodeRevertReason('nonce mismatch') });
            const paid = paymasterBalance.sub(await relayHubInstance.balanceOf(paymaster)).toNumber();
            assert.equal(paid, 0);
        });
        it('paymaster SHOULD pay for Forwarder revert ABOVE commitment', async () => {
            // instead of creating a custom forwarder with takes a lot of gas, we lower
            // the commitment, so normal paymaster will be above it.
            await paymasterContract.setGasLimits(10000, 50000, 10000);
            // NOTE: as long as commitment > preRelayedCallGasLimit
            const r = await makeRequest(web3, {
                request: {
                    nonce: '4',
                    data: recipientContract.contract.methods.emitMessage('').encodeABI()
                },
                relayData: { paymaster }
            }, sharedRelayRequestData, chainId, forwarderInstance);
            const res = await relayHubInstance.relayCall(10e6, r.req, r.sig, '0x', externalGasLimit, {
                from: relayWorker,
                gas: externalGasLimit,
                gasPrice
            });
            test_helpers_1.expectEvent(res, 'TransactionRelayed', { status: RelayCallStatusCodes.RejectedByForwarder });
        });
        it('paymaster should not pay for trusted-recipient revert (within commitment)', async () => {
            await paymasterContract.setTrustRecipientRevert(true);
            const r = await makeRequest(web3, {
                request: {
                    data: recipientContract.contract.methods.testRevert().encodeABI()
                },
                relayData: { paymaster }
            }, sharedRelayRequestData, chainId, forwarderInstance);
            const res = await relayHubInstance.relayCall(10e6, r.req, r.sig, '0x', externalGasLimit, {
                from: relayWorker,
                gas: externalGasLimit,
                gasPrice
            });
            test_helpers_1.expectEvent(res, 'TransactionRejectedByPaymaster', { reason: TestUtils_1.encodeRevertReason('always fail') });
            const paid = paymasterBalance.sub(await relayHubInstance.balanceOf(paymaster)).toNumber();
            assert.equal(paid, 0);
        });
        it('paymaster SHOULD pay for trusted-recipient revert (above commitment)', async () => {
            await paymasterContract.setGasLimits(10000, 50000, 10000);
            await paymasterContract.setTrustRecipientRevert(true);
            const r = await makeRequest(web3, {
                request: {
                    data: recipientContract.contract.methods.testRevert().encodeABI()
                },
                relayData: { paymaster }
            }, sharedRelayRequestData, chainId, forwarderInstance);
            const res = await relayHubInstance.relayCall(10e6, r.req, r.sig, '0x', externalGasLimit, {
                from: relayWorker,
                gas: externalGasLimit,
                gasPrice
            });
            test_helpers_1.expectEvent(res, 'TransactionRelayed', { status: RelayCallStatusCodes.RejectedByRecipientRevert });
        });
    });
});
//# sourceMappingURL=PaymasterCommitment.test.js.map